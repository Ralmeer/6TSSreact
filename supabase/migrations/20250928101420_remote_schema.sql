create sequence "public"."attendance_id_seq";

create sequence "public"."attendance_scouts_id_seq";

create sequence "public"."badges_id_seq";

create sequence "public"."debug_logs_id_seq";

create sequence "public"."leader_info_id_seq";

create sequence "public"."notices_id_seq";

create sequence "public"."scout_badges_id_seq";

create sequence "public"."scouts_id_seq";

create sequence "public"."userroles_id_seq";

create table "public"."activities" (
    "id" integer generated by default as identity not null,
    "name" character varying(255) not null,
    "description" text,
    "activity_type" character varying(255)
);


create table "public"."attendance" (
    "id" integer not null default nextval('attendance_id_seq'::regclass),
    "date" date not null,
    "activity_type" character varying(50) not null,
    "custom_activity_name" character varying(255),
    "created_by" uuid,
    "created_at" timestamp with time zone default now()
);


alter table "public"."attendance" enable row level security;

create table "public"."attendance_scouts" (
    "id" integer not null default nextval('attendance_scouts_id_seq'::regclass),
    "attendance_id" integer,
    "scout_id" integer
);


alter table "public"."attendance_scouts" enable row level security;

create table "public"."badges" (
    "id" integer not null default nextval('badges_id_seq'::regclass),
    "name" character varying(255) not null,
    "description" text,
    "requirements" text,
    "created_at" timestamp with time zone default now(),
    "badge_type" character varying(50) not null default 'Proficiency Badge'::character varying
);


alter table "public"."badges" enable row level security;

create table "public"."debug_logs" (
    "id" integer not null default nextval('debug_logs_id_seq'::regclass),
    "timestamp" timestamp with time zone default now(),
    "message" text,
    "user_id" uuid,
    "extra_data" jsonb
);


create table "public"."leader_info" (
    "id" integer not null default nextval('leader_info_id_seq'::regclass),
    "content" text not null,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid
);


alter table "public"."leader_info" enable row level security;

create table "public"."notices" (
    "id" integer not null default nextval('notices_id_seq'::regclass),
    "title" text not null,
    "description" text not null,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid,
    "active" boolean default true
);


alter table "public"."notices" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "username" text not null,
    "avatar_url" text,
    "updated_at" timestamp with time zone default now()
);


alter table "public"."profiles" enable row level security;

create table "public"."scout_activities" (
    "id" bigint generated by default as identity not null,
    "scout_id" integer,
    "activity_type" character varying(255) not null,
    "activity_name" text,
    "date" date not null,
    "created_at" timestamp with time zone default now(),
    "activity_id" integer,
    "date_attended" date
);


alter table "public"."scout_activities" enable row level security;

create table "public"."scout_badges" (
    "id" integer not null default nextval('scout_badges_id_seq'::regclass),
    "scout_id" integer,
    "badge_id" integer,
    "date_earned" date not null,
    "awarded_by" uuid,
    "created_at" timestamp with time zone default now()
);


alter table "public"."scout_badges" enable row level security;

create table "public"."scout_history" (
    "id" integer generated by default as identity not null,
    "scout_id" integer not null,
    "rank" character varying,
    "crew" character varying,
    "start_date" date,
    "end_date" date,
    "created_at" timestamp with time zone default now()
);


alter table "public"."scout_history" enable row level security;

create table "public"."scouts" (
    "id" integer not null default nextval('scouts_id_seq'::regclass),
    "full_name" character varying(255) not null,
    "crew" character varying(50),
    "email" character varying(255),
    "rank" character varying(30),
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "registration_token" character varying(128),
    "registration_token_expires" timestamp with time zone,
    "password" text,
    "reset_token" text,
    "reset_token_created_at" timestamp with time zone,
    "user_id" uuid not null,
    "avatar_url" text
);


alter table "public"."scouts" enable row level security;

create table "public"."userroles" (
    "id" integer not null default nextval('userroles_id_seq'::regclass),
    "user_id" uuid,
    "userrole" character varying(30),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."userroles" enable row level security;

alter sequence "public"."attendance_id_seq" owned by "public"."attendance"."id";

alter sequence "public"."attendance_scouts_id_seq" owned by "public"."attendance_scouts"."id";

alter sequence "public"."badges_id_seq" owned by "public"."badges"."id";

alter sequence "public"."debug_logs_id_seq" owned by "public"."debug_logs"."id";

alter sequence "public"."leader_info_id_seq" owned by "public"."leader_info"."id";

alter sequence "public"."notices_id_seq" owned by "public"."notices"."id";

alter sequence "public"."scout_badges_id_seq" owned by "public"."scout_badges"."id";

alter sequence "public"."scouts_id_seq" owned by "public"."scouts"."id";

alter sequence "public"."userroles_id_seq" owned by "public"."userroles"."id";

CREATE UNIQUE INDEX activities_pkey ON public.activities USING btree (id);

CREATE UNIQUE INDEX attendance_pkey ON public.attendance USING btree (id);

CREATE UNIQUE INDEX attendance_scouts_attendance_id_scout_id_key ON public.attendance_scouts USING btree (attendance_id, scout_id);

CREATE UNIQUE INDEX attendance_scouts_pkey ON public.attendance_scouts USING btree (id);

CREATE UNIQUE INDEX badges_pkey ON public.badges USING btree (id);

CREATE UNIQUE INDEX debug_logs_pkey ON public.debug_logs USING btree (id);

CREATE INDEX idx_attendance_date ON public.attendance USING btree (date);

CREATE INDEX idx_attendance_scouts_attendance_id ON public.attendance_scouts USING btree (attendance_id);

CREATE INDEX idx_attendance_scouts_scout_id ON public.attendance_scouts USING btree (scout_id);

CREATE INDEX idx_scout_badges_scout_id ON public.scout_badges USING btree (scout_id);

CREATE INDEX idx_scouts_crew ON public.scouts USING btree (crew);

CREATE INDEX idx_scouts_email ON public.scouts USING btree (email);

CREATE INDEX idx_scouts_rank ON public.scouts USING btree (rank);

CREATE INDEX idx_scouts_registration_token ON public.scouts USING btree (registration_token);

CREATE INDEX idx_userroles_role ON public.userroles USING btree (userrole);

CREATE INDEX idx_userroles_user_id ON public.userroles USING btree (user_id);

CREATE UNIQUE INDEX leader_info_pkey ON public.leader_info USING btree (id);

CREATE UNIQUE INDEX notices_pkey ON public.notices USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

CREATE UNIQUE INDEX scout_activities_pkey ON public.scout_activities USING btree (id);

CREATE UNIQUE INDEX scout_badges_pkey ON public.scout_badges USING btree (id);

CREATE UNIQUE INDEX scout_badges_scout_id_badge_id_key ON public.scout_badges USING btree (scout_id, badge_id);

CREATE UNIQUE INDEX scout_history_pkey ON public.scout_history USING btree (id);

CREATE UNIQUE INDEX scouts_email_key ON public.scouts USING btree (email);

CREATE UNIQUE INDEX scouts_pkey ON public.scouts USING btree (id);

CREATE UNIQUE INDEX unique_activity_name ON public.activities USING btree (name);

CREATE UNIQUE INDEX unique_registration_token ON public.scouts USING btree (registration_token);

CREATE UNIQUE INDEX unique_scout_email ON public.scouts USING btree (email);

CREATE UNIQUE INDEX unique_user_id ON public.scouts USING btree (user_id);

CREATE UNIQUE INDEX userroles_pkey ON public.userroles USING btree (id);

CREATE UNIQUE INDEX userroles_user_id_key ON public.userroles USING btree (user_id);

alter table "public"."activities" add constraint "activities_pkey" PRIMARY KEY using index "activities_pkey";

alter table "public"."attendance" add constraint "attendance_pkey" PRIMARY KEY using index "attendance_pkey";

alter table "public"."attendance_scouts" add constraint "attendance_scouts_pkey" PRIMARY KEY using index "attendance_scouts_pkey";

alter table "public"."badges" add constraint "badges_pkey" PRIMARY KEY using index "badges_pkey";

alter table "public"."debug_logs" add constraint "debug_logs_pkey" PRIMARY KEY using index "debug_logs_pkey";

alter table "public"."leader_info" add constraint "leader_info_pkey" PRIMARY KEY using index "leader_info_pkey";

alter table "public"."notices" add constraint "notices_pkey" PRIMARY KEY using index "notices_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."scout_activities" add constraint "scout_activities_pkey" PRIMARY KEY using index "scout_activities_pkey";

alter table "public"."scout_badges" add constraint "scout_badges_pkey" PRIMARY KEY using index "scout_badges_pkey";

alter table "public"."scout_history" add constraint "scout_history_pkey" PRIMARY KEY using index "scout_history_pkey";

alter table "public"."scouts" add constraint "scouts_pkey" PRIMARY KEY using index "scouts_pkey";

alter table "public"."userroles" add constraint "userroles_pkey" PRIMARY KEY using index "userroles_pkey";

alter table "public"."activities" add constraint "unique_activity_name" UNIQUE using index "unique_activity_name";

alter table "public"."attendance" add constraint "attendance_activity_type_check" CHECK (((activity_type)::text = ANY ((ARRAY['Kayaking'::character varying, 'Swimming'::character varying, 'Meeting'::character varying, 'Camps'::character varying, 'Hikes'::character varying, 'Other'::character varying, 'Service'::character varying])::text[]))) not valid;

alter table "public"."attendance" validate constraint "attendance_activity_type_check";

alter table "public"."attendance" add constraint "attendance_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."attendance" validate constraint "attendance_created_by_fkey";

alter table "public"."attendance_scouts" add constraint "attendance_scouts_attendance_id_fkey" FOREIGN KEY (attendance_id) REFERENCES attendance(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_scouts" validate constraint "attendance_scouts_attendance_id_fkey";

alter table "public"."attendance_scouts" add constraint "attendance_scouts_attendance_id_scout_id_key" UNIQUE using index "attendance_scouts_attendance_id_scout_id_key";

alter table "public"."attendance_scouts" add constraint "attendance_scouts_scout_id_fkey" FOREIGN KEY (scout_id) REFERENCES scouts(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_scouts" validate constraint "attendance_scouts_scout_id_fkey";

alter table "public"."badges" add constraint "valid_badge_type" CHECK (((badge_type)::text = ANY ((ARRAY['Proficiency Badge'::character varying, 'Stage Badge'::character varying, 'Event Badge'::character varying, 'Advancement Badge'::character varying, 'Challenge Badge'::character varying])::text[]))) not valid;

alter table "public"."badges" validate constraint "valid_badge_type";

alter table "public"."leader_info" add constraint "leader_info_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."leader_info" validate constraint "leader_info_updated_by_fkey";

alter table "public"."notices" add constraint "notices_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."notices" validate constraint "notices_created_by_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."scout_activities" add constraint "fk_activity" FOREIGN KEY (activity_id) REFERENCES activities(id) not valid;

alter table "public"."scout_activities" validate constraint "fk_activity";

alter table "public"."scout_activities" add constraint "scout_activities_scout_id_fkey" FOREIGN KEY (scout_id) REFERENCES scouts(id) ON DELETE CASCADE not valid;

alter table "public"."scout_activities" validate constraint "scout_activities_scout_id_fkey";

alter table "public"."scout_badges" add constraint "scout_badges_awarded_by_fkey" FOREIGN KEY (awarded_by) REFERENCES auth.users(id) not valid;

alter table "public"."scout_badges" validate constraint "scout_badges_awarded_by_fkey";

alter table "public"."scout_badges" add constraint "scout_badges_badge_id_fkey" FOREIGN KEY (badge_id) REFERENCES badges(id) ON DELETE CASCADE not valid;

alter table "public"."scout_badges" validate constraint "scout_badges_badge_id_fkey";

alter table "public"."scout_badges" add constraint "scout_badges_scout_id_badge_id_key" UNIQUE using index "scout_badges_scout_id_badge_id_key";

alter table "public"."scout_badges" add constraint "scout_badges_scout_id_fkey" FOREIGN KEY (scout_id) REFERENCES scouts(id) ON DELETE CASCADE not valid;

alter table "public"."scout_badges" validate constraint "scout_badges_scout_id_fkey";

alter table "public"."scout_history" add constraint "scout_history_scout_id_fkey" FOREIGN KEY (scout_id) REFERENCES scouts(id) not valid;

alter table "public"."scout_history" validate constraint "scout_history_scout_id_fkey";

alter table "public"."scouts" add constraint "fk_user_id" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."scouts" validate constraint "fk_user_id";

alter table "public"."scouts" add constraint "scouts_email_key" UNIQUE using index "scouts_email_key";

alter table "public"."scouts" add constraint "unique_registration_token" UNIQUE using index "unique_registration_token";

alter table "public"."scouts" add constraint "unique_scout_email" UNIQUE using index "unique_scout_email";

alter table "public"."scouts" add constraint "unique_user_id" UNIQUE using index "unique_user_id";

alter table "public"."scouts" add constraint "valid_crews" CHECK (((crew)::text = ANY ((ARRAY['Kingfishers'::character varying, 'Dolphins'::character varying, 'Barracudas'::character varying, 'Orcas'::character varying, 'Falcons'::character varying, 'Swifts'::character varying, 'Marlins'::character varying, 'Terns'::character varying, 'Seals'::character varying, 'Junior Executive'::character varying, 'Senior Executive'::character varying, 'Crewless'::character varying, 'Alpha'::character varying, 'Bravo'::character varying, 'Charlie'::character varying, 'Delta'::character varying])::text[]))) not valid;

alter table "public"."scouts" validate constraint "valid_crews";

alter table "public"."scouts" add constraint "valid_ranks" CHECK (((rank)::text = ANY (ARRAY[('Waster'::character varying)::text, ('Recruit'::character varying)::text, ('Scout'::character varying)::text, ('Venture Scout'::character varying)::text, ('Assistant Crew Leader'::character varying)::text, ('Crew Leader'::character varying)::text, ('Executive'::character varying)::text]))) not valid;

alter table "public"."scouts" validate constraint "valid_ranks";

alter table "public"."userroles" add constraint "userroles_role_check" CHECK (((userrole)::text = ANY (ARRAY[('leader'::character varying)::text, ('scout'::character varying)::text]))) not valid;

alter table "public"."userroles" validate constraint "userroles_role_check";

alter table "public"."userroles" add constraint "userroles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."userroles" validate constraint "userroles_user_id_fkey";

alter table "public"."userroles" add constraint "userroles_user_id_key" UNIQUE using index "userroles_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_scout_if_not_exists(p_user_id uuid, p_full_name text, p_email text, p_rank text, p_crew text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if a scout with the given user_id already exists
    IF EXISTS (SELECT 1 FROM public.scouts WHERE user_id = p_user_id) THEN
        -- If yes, update the existing scout
        UPDATE public.scouts
        SET full_name = p_full_name, email = p_email, rank = p_rank, crew = p_crew
        WHERE user_id = p_user_id;
    ELSIF NOT EXISTS (SELECT 1 FROM public.scouts WHERE email = p_email) THEN
        -- If no scout with user_id, and no scout with email, insert the new scout
        INSERT INTO public.scouts (user_id, full_name, email, rank, crew)
        VALUES (p_user_id, p_full_name, p_email, p_rank, p_crew);
    ELSE
        -- If a scout with the email exists but not with the user_id, raise an exception
        RAISE EXCEPTION 'A scout with this email already exists.';
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_scout_history(p_scout_id integer)
 RETURNS TABLE(rank character varying, crew character varying, start_date timestamp with time zone, end_date timestamp with time zone, duration text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sh.rank,
    sh.crew,
    sh.start_date,
    sh.end_date,
    CASE 
      WHEN sh.end_date IS NULL THEN 
        'Current (' || EXTRACT(DAY FROM NOW() - sh.start_date)::TEXT || ' days)'
      ELSE 
        EXTRACT(DAY FROM sh.end_date - sh.start_date)::TEXT || ' days'
    END AS duration
  FROM scout_history sh
  WHERE sh.scout_id = p_scout_id
  ORDER BY sh.start_date DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RAISE NOTICE 'handle_new_user triggered for user ID: %', NEW.id;
  RAISE NOTICE 'User email: %', NEW.email;
  RAISE NOTICE 'Raw user metadata: %', NEW.raw_user_meta_data;
  RAISE NOTICE 'Userrole from metadata: %', (NEW.raw_user_meta_data->>'userrole')::text;

  -- Insert into the 'scouts' table
  IF new.raw_user_meta_data->>'userrole' = 'scout' THEN
    INSERT INTO public.scouts (user_id, full_name, email, crew, rank)
    VALUES (new.id, new.raw_user_meta_data->>'name', new.email, new.raw_user_meta_data->>'crew', new.raw_user_meta_data->>'rank');
  END IF;

  INSERT INTO public.userroles (user_id, userrole)
  VALUES (new.id, new.raw_user_meta_data->>'userrole');

  RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.initialize_scout_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Insert initial history record
  INSERT INTO public.scout_history (scout_id, rank, crew)
  VALUES (NEW.id, NEW.rank, NEW.crew);

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_scout_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If rank or crew has changed
  IF (OLD.rank <> NEW.rank OR OLD.crew <> NEW.crew) THEN
    -- Close the current period for this scout
    UPDATE scout_history
    SET end_date = NOW()
    WHERE scout_id = NEW.id AND end_date IS NULL;
    
    -- Insert a new record with the updated values
    INSERT INTO scout_history (scout_id, rank, crew)
    VALUES (NEW.id, NEW.rank, NEW.crew);
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_scout_email_from_auth()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF OLD.email IS DISTINCT FROM NEW.email THEN
        UPDATE public.scouts
        SET email = NEW.email
        WHERE email = OLD.email;
    END IF;
    RETURN NEW;
END;
$function$
;

create policy "Leader full access"
on "public"."attendance"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scout can view own attendance"
on "public"."attendance"
as permissive
for select
to public
using ((id IN ( SELECT attendance_scouts.attendance_id
   FROM attendance_scouts
  WHERE (attendance_scouts.scout_id IN ( SELECT scouts.id
           FROM scouts
          WHERE ((scouts.email)::text = auth.email()))))));


create policy "Leader full access"
on "public"."attendance_scouts"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scout can view own attendance_scouts"
on "public"."attendance_scouts"
as permissive
for select
to public
using ((scout_id IN ( SELECT scouts.id
   FROM scouts
  WHERE ((scouts.email)::text = auth.email()))));


create policy "Leader full access to badges"
on "public"."badges"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scouts can view all badges"
on "public"."badges"
as permissive
for select
to public
using (true);


create policy "Leaders can manage leader info"
on "public"."leader_info"
as permissive
for all
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scouts can read leader info"
on "public"."leader_info"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'scout'::text)))));


create policy "Leaders can manage notices"
on "public"."notices"
as permissive
for all
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scouts can read active notices"
on "public"."notices"
as permissive
for select
to authenticated
using (((active = true) AND (EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'scout'::text))))));


create policy "Users can create their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update their own profile."
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Users can view their own profile."
on "public"."profiles"
as permissive
for select
to public
using ((auth.uid() = id));


create policy "Enable delete for authenticated users only"
on "public"."scout_activities"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users only"
on "public"."scout_activities"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for all users"
on "public"."scout_activities"
as permissive
for select
to public
using (true);


create policy "Enable update for authenticated users only"
on "public"."scout_activities"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text));


create policy "Leader full access"
on "public"."scout_badges"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scout can view own badges"
on "public"."scout_badges"
as permissive
for select
to public
using ((scout_id IN ( SELECT scouts.id
   FROM scouts
  WHERE ((scouts.email)::text = auth.email()))));


create policy "Enable read access for authenticated users to their own scout h"
on "public"."scout_history"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM scouts
  WHERE ((scouts.id = scout_history.scout_id) AND (scouts.user_id = auth.uid())))));


create policy "Allow individual scout to insert their own profile"
on "public"."scouts"
as permissive
for insert
to authenticated
with check (((email)::text = auth.email()));


create policy "Enable insert access for authenticated users to their own scout"
on "public"."scouts"
as permissive
for insert
to authenticated
with check ((auth.uid() = user_id));


create policy "Enable read access for authenticated users to their own scout r"
on "public"."scouts"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Leader full access"
on "public"."scouts"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))))
with check ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Only leaders can delete scout profiles"
on "public"."scouts"
as permissive
for delete
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Only leaders can update scout profiles"
on "public"."scouts"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles
  WHERE ((userroles.user_id = auth.uid()) AND ((userroles.userrole)::text = 'leader'::text)))));


create policy "Scout can view own record"
on "public"."scouts"
as permissive
for select
to public
using (((email)::text = auth.email()));


create policy "Allow leaders to insert roles and users to insert their own"
on "public"."userroles"
as permissive
for insert
to authenticated
with check (((EXISTS ( SELECT 1
   FROM userroles userroles_1
  WHERE ((userroles_1.user_id = auth.uid()) AND ((userroles_1.userrole)::text = 'leader'::text)))) OR (user_id = auth.uid())));


create policy "Leader can delete roles"
on "public"."userroles"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM userroles ur
  WHERE ((ur.user_id = auth.uid()) AND ((ur.userrole)::text = 'leader'::text)))));


create policy "Leader can update roles"
on "public"."userroles"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM userroles ur
  WHERE ((ur.user_id = auth.uid()) AND ((ur.userrole)::text = 'leader'::text)))));


create policy "Only leaders can delete userroles"
on "public"."userroles"
as permissive
for delete
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles userroles_1
  WHERE ((userroles_1.user_id = auth.uid()) AND ((userroles_1.userrole)::text = 'leader'::text)))));


create policy "Only leaders can update userroles"
on "public"."userroles"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM userroles userroles_1
  WHERE ((userroles_1.user_id = auth.uid()) AND ((userroles_1.userrole)::text = 'leader'::text)))));


create policy "Scout can view own role"
on "public"."userroles"
as permissive
for select
to public
using ((user_id = auth.uid()));


create policy "User can view own role"
on "public"."userroles"
as permissive
for select
to public
using ((user_id = auth.uid()));


CREATE TRIGGER scout_insert_trigger AFTER INSERT ON public.scouts FOR EACH ROW EXECUTE FUNCTION initialize_scout_history();

CREATE TRIGGER scout_update_trigger AFTER UPDATE ON public.scouts FOR EACH ROW EXECUTE FUNCTION record_scout_history();


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();

CREATE TRIGGER on_auth_user_email_change AFTER UPDATE OF email ON auth.users FOR EACH ROW EXECUTE FUNCTION update_scout_email_from_auth();


